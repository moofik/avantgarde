# Implementation Card — IParamBridge / ParamBridgeDualBuffer

## Цель
Создать RT-безопасный мост параметров между **Control Plane** и **Audio RT Core**, обеспечивающий:
- запись параметров контролем в `write`-буфер без блокировок;
- атомарный `swap` (`write ↔ read`) в начале каждого аудио-блока;
- только чтение снапшота параметров из RT-кода;
- нормализацию всех значений в диапазон **[0..1]** и детерминированное поведение.

---

## Контрактный контекст
**Интерфейс:** `IParamBridge` *(версия будет уточнена по CONTRACTS.md)*  
**Базовые типы:** `ParamId`, `ModuleId`, `TrackId` — из `types.h`

**Инварианты контракта:**
1. RT-методы не выполняют аллокации, исключения и блокировки.  
2. Все структуры, пересекающие границу RT, — POD фиксированной длины.  
3. Все значения параметров нормализованы в `[0..1]`.  
4. `swap` выполняется строго один раз на аудио-блок.

---

## Область применения
- FX-ноды графа читают локальные кэши, обновляемые из `IParamBridge` после `swap`.  
- Control Plane (энкодеры, кнопки, страницы) пишет значения в `write`-буфер с пикап-логикой и сглаживанием (10–50 мс).

---

## Публичный API *(черновой, финализируется после сверки с CONTRACTS.md)*
```cpp
bool   setParam(ModuleId m, ParamId p, float normValue) noexcept;
float  getParam(ModuleId m, ParamId p) const noexcept;
void   commitWrite() noexcept;
void   rtSwapBeginBlock() noexcept;
```

**Опционально:**
```cpp
bool        setParams(span<const ParamUpdate>) noexcept;
uint32_t    epoch() const noexcept;   // версия снапшота
```

---

## Потоки и RT-гарантии
| Поток     | Операции                           | RT-гарантии                                 |
|------------|------------------------------------|----------------------------------------------|
| Control    | запись в `write`                   | без блокировок, без исключений              |
| RT         | `rtSwapBeginBlock()` + чтение `read` | без аллокаций, без ветвлений, атомарный флаг |

---

## Формат данных и адресация
- Простая адресация: `(ModuleId, ParamId) → float[0..1]`.  
- Внутреннее хранение — двойной массив или SoA для кэш-дружественного доступа.  
- Размерность (кол-во модулей и параметров) задаётся при создании экземпляра.

---

## Обработка значений
- Все входные значения клампятся к `[0..1]`.  
- В `write`-буфере допускается лёгкое линейное сглаживание (если не вынесено в Control Plane).  
- По умолчанию сглаживание выполняется на стороне UI.

---

## Ошибки и диагностика
- **RT-путь:** без логирования; нарушения инвариантов — `assert` (при `NDEBUG = off`).  
- **Control-путь:** мягкие статусы возврата (`bool` / `enum Error`), без исключений.  
- Проверки: валидность идентификаторов, размерности и готовность к `swap`.

---

## RT-бюджет
- `rtSwapBeginBlock()` — `O(Nparams)` с `memcpy` или двойным указателем.  
- При необходимости оптимизации — dirty-bitmap для частичных копий.  
- Цель: **< 10 µs** на блок при ~1–2 k параметров (ARM A7/A53).

---

## Зависимости
- `types.h` — идентификаторы.  
- *(опц.)* `IAudioEngine` — точка вызова `swap`.  
- Без зависимостей от сервис-слоя (лог, SD, OLED и т.д.).

---

## Интеграционные точки
- **Audio RT Core:** вызывает `rtSwapBeginBlock()` перед обработкой графа.  
- **FX-ноды:** читают локальный `paramCache` из снапшота на старте блока.  
- **Control Plane:** пишет значения в `write` (пикап / страницы / ассайн 6 крутилок).

---

## Тест-план
1. **Swap атомарность** — при конкурентной записи Control и вызове `rtSwapBeginBlock()` данные консистентны.  
2. **Без гонок** — проверка TSAN на модельной гонке записи/чтения.  
3. **Диапазоны** — все значения в `[0..1]`, клампинг подтверждён.  
4. **Производительность** — N = 2k/5k параметров укладывается в бюджет.  
5. **Dirty-bitmap** — частичный swap копирует только изменённые значения.  
6. **Determinism** — повторяемость при одинаковой последовательности `setParam`/`swap`.  
7. **Zero-alloc / Zero-throw** — профилирование RT-потока.

---

## Риски и решения
| Риск | Решение |
|------|----------|
| Большой объём параметров | Частичный swap по dirty-bitmap |
| Расхождение карт модулей | Валидаторы при init, мягкие ошибки при `setParam` |
| Двойное сглаживание | Сглаживание остаётся в Control Plane |

---

## Definition of Done
- `ParamBridgeDualBuffer` полностью соответствует контракту `IParamBridge` и RT-правилам.  
- Все юнит-тесты и интеграционные проверки пройдены.  
- Профилирование подтверждает RT-бюджет.  
- Карточка и код сверены с `CONTRACTS.md`.
